---
layout: post
tag: Project
---

## [TrafficSimulator] Vehicle Behavior

In order to simulate the intersection traffic, there are two big things to consider: Traffic lights, and vehicles.

There are several ways to choose for vehicle movement.

### Finding Path

1\. Using waypoints for path planning

-   Cannot detect other vehicles
-   Robust when the map information given
-   GPS information can be used to plan the path in real-life
-   Easy to implement and understand, but manual setup of paths required.

2\. Navmesh (Navigation meshes)

-   Can avoid obstacle easily.
-   Can find the optimal path within walkable area.
-   Hard to make turns due to comparatively less control over the desired path.

3\. A\* algorithm

-   Efficient and accurate to find the optimal path
-   Can be combined with steering behaviors for realistic curving.
-   Limited scalability due to the calculation.

### Behavior

1\. Raycast to stay on the lane

![image](https://github.com/Picbridge/Picbridge.github.io/assets/34910988/2f7165dc-2b43-4016-90c8-2b1d0622854c)

Raycsting: Green for forward detection (can be reduced to 1 based on usage), Magenta for lanes

-   Great for a single lane circuit, but not effective for intersection simulation when used alone.
-   Vision cone may also work.
-   Focused on obstacle avoidance
-   Can be expensive if overly used.

2\. Finite State Machines (FSM)

-   Simple to implement, excellent for simple behavior.
-   Fewer states is better.

3\. Behavior Trees

-   More flexible than FSMs.
-   Debugging can be challenging.

### Progress

In this project, Navmesh, waypoint, raycasting, and behavior tree is used. Applied raycasting to shift between leaf nodes of behavior tree, and applied waypoints to Navmesh to make a smooth turn.

Here is the basis used for behavior tree nodes

```
    public enum BT_NodeStates
    {
        SUCCESS,
        FAILURE,
        RUNNING
    }


    public abstract class BT_Node
    {
        protected BT_NodeStates currState;

        public BT_NodeStates getNodeState
        {
            get { return currState; }
        }

        public abstract BT_NodeStates Evaluate();
    }
```

All the nodes inherit BT\_Node.

These are the nodes used in this project:

-   Control flow nodes
    -   Sequencer
    -   Selector
-   Decorative nodes
    -   Inverter
-   Leaf nodes (Execution)
    -   Approach
    -   CheckArrival
    -   Detect
    -   SetDestination

No need stop since the agent won't move if something detected.

The completed vehicle behavior roughly looks like this:

```
    BT_Sequencer detectionSequence = new BT_Sequence(new List<BT_Node>
    {
        new BT_Inverter(new Detect()),
        new CheckArrival(),
        new SetDestination()
    });

    BT_Selector root = new BT_Selector(new List<BT_Node>
    {
        detectionSequence,
        new Approach(),
    });
```

The Detect detects whether if there's any obstacle in the way or it the traffic light is red. Agent stops whenever something is detected, and generates the path if the detected object is the stop lane.

![image](https://github.com/Picbridge/Picbridge.github.io/assets/34910988/ac106829-75c6-4b02-9132-5d792be29c69)

The way point is generated by getting the line from starting position to destination, derive the target perpendicular line to get the center of the rotating circle based on which direction the vehicle is turning.

![image](https://github.com/Picbridge/Picbridge.github.io/assets/34910988/be336dd4-71b1-443e-8217-4035a5308569)

If the vehicle is turning to right, we can derive the target direction vector using cross product (start to destination, up vector), and opposite order for turning left.

![image](https://github.com/Picbridge/Picbridge.github.io/assets/34910988/6134da22-aa23-4c33-b71c-de966a51a9d8)

Mid point is the average between start point and destination. In order to make a circular turn, we need the center point. This can be calculated by getting the intersecting point between the agent right vector and derived perpendicular vector.

The intersecting point between two vectors can be calculated by solving two linear equations.  
Each line representation looks like C = Ax + Bz where A and B are coefficients derived from direction vector, and C is a constant.  
In order to check if the line is not parallel, we need to set delta where delta is A1B2 - A2B1. If the delta is zero, the lines are parallel.  
After checking the parallelism, we can apply Cramer's rule to actually calulate the intersecting point.

```
    Vector3 GetIntersectionPoint(Vector3 pt1, Vector3, dir1, Vector3 pt2, Vector3 dir2)
    {
        A1 = dir1.z;
        B1 = -dir1.x;
        C1 = (A1 * pt1.x) + (B1 * pt2.z); //Ax + Bz = C

        //Do same for A2, B2, and C2

        delta = (A1 * B2) - (A2 * B1);

        if (delta is zero) //Handle exception

        //Cramer's rule
        x = ((B2 * C1) - (B1 * C2)) / delta;
        z = ((A1 * C2) - (A2 * C1)) / delta;

        return Vector(x, p1.y, z);
    }
```

And then simply move through the circle with radius of length between center to agent position and generate the waypoint.

The next step will be to integrate the meta AI for environmental settings.
